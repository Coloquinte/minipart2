// Copyright (C) 2019 Gabriel Gouvine - All Rights Reserved

#include "hypergraph.hh"
#include "solution.hh"

#include <memory>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/gzip.hpp>

using namespace std;

namespace minipart {

namespace {

stringstream getUncommentedLine(istream &s) {
  // Get rid of comment lines and empty lines
  string tmp;
  do {
    if (!s.good()) throw runtime_error("Not enough lines");
    getline(s, tmp);
  } while(tmp.empty() || tmp[0] == '%');

  return stringstream(tmp);
}

} // End anonymous namespace


Hypergraph Hypergraph::readHgr(istream &s) {
  Index nNodes, nHedges, params;

  stringstream ss = getUncommentedLine(s);
  ss >> nHedges >> nNodes;
  if (ss.fail()) throw runtime_error("Invalid first line");
  ss >> params;
  if (ss.fail()) params = 0;

  if (params != 0 && params != 1 && params != 10 && params != 11) throw runtime_error("Invalid parameter value");

  bool hasHedgeWeights = (params == 11) || (params == 1);
  bool hasNodeWeights = (params == 11) || (params == 10);

  Hypergraph ret;

  // Read edges
  ret.hedgeWeights_.reserve(nHedges);
  ret.hedgeToNodes_.reserve(nHedges);
  vector<Index> nodes;
  for (Index i = 0; i < nHedges; ++i) {
    ss = getUncommentedLine(s);

    Index w = 1;
    if (hasHedgeWeights) ss >> w;

    while (ss) {
        Index n;
        ss >> n;
        if (ss.fail()) continue;
        if (n > nNodes) throw runtime_error("Parsed pin index is outside the specified number of nodes");
        if (n == 0) throw runtime_error("Parsed pin index cannot be 0");
        nodes.push_back(n-1);
    }
    sort(nodes.begin(), nodes.end());
    nodes.resize(unique(nodes.begin(), nodes.end()) - nodes.begin());
    if (nodes.empty()) throw runtime_error("No node on the line");
    ret.hedgeWeights_.push_back(w);
    ret.hedgeToNodes_.push_back(nodes);
    nodes.clear();
  }

  // Read node weights
  ret.nodeWeights_.reserve(nNodes);
  if (hasNodeWeights) {
    vector<Index> demands;
    for (Index i = 0; i < nNodes; ++i) {
      ss = getUncommentedLine(s);
      while (ss) {
        Index w;
        ss >> w;
        if (ss.fail()) continue;
        demands.push_back(w);
      }
      if (demands.size() != 1) throw runtime_error("All nodes should have exactly one weight");
      ret.nodeWeights_.push_back(demands.front());
      demands.clear();
    }
  }
  else {
    ret.nodeWeights_.assign(nNodes, 1);
  }

  // Finalize nodes 
  ret.constructNodes();

  return ret;
}

void Hypergraph::writeHgr(ostream &s) const {
  Index totNodeWeight = totalNodeWeight();
  Index totHedgeWeight = totalHedgeWeight();
  Index totPinCount = nPins();
  s << "% HGR (hMetis) file generated by Minipart\n";
  s << "%\n";
  s << "% nodes: " << nNodes() << "\n";
  s << "% hyperedges: " << nHedges() << "\n";
  s << "%\n";
  s << "% average node degree: " << (double) totPinCount / nNodes() << "\n";
  s << "% average hyperedge degree: " << (double) totPinCount / nHedges() << "\n";
  s << "% average node weight: " << (double) totNodeWeight / nNodes() << "\n";
  s << "% average hyperedge weight: " << (double) totHedgeWeight / nHedges() << "\n";
  s << "%\n";
  s << "%\n";

  s << nHedges() << " " << nNodes() << " 11\n";
  for (Index hedge = 0; hedge < nHedges(); ++hedge) {
    s << hedgeWeight(hedge);
    for (Index node : hedgeNodes(hedge)) {
      s << " " << node + 1;
    }
    s << "\n";
  }
  for (Index node = 0; node < nNodes(); ++node) {
    s << nodeWeight(node) << "\n";
  }
}

Solution Solution::read(istream &s) {
  vector<Index> parts;
  while (s.good()) {
    Index p;
    s >> p;
    if (s.fail()) break;
    parts.push_back(p);
  }
  return Solution(parts);
}

void Solution::write(ostream &s) const {
  for (Index p : parts_) {
    s << p << "\n";
  }
  s.flush();
}

namespace {
bool isGzipFilename(const string &name) {
  return name.size() >= 3 && name.compare(name.size() - 3, 3, ".gz") == 0;
}
}

Solution Solution::readFile(const string &name) {
  if (isGzipFilename(name)) {
    ifstream file(name, ios_base::in | ios_base::binary);
    if (file.fail()) throw runtime_error("Unable to open the file \"" + name + "\"");
    boost::iostreams::filtering_streambuf<boost::iostreams::input> in;
    in.push(boost::iostreams::gzip_decompressor());
    in.push(file);
    std::istream inf(&in);
    return Solution::read(inf);
  }
  else {
    ifstream file(name);
    if (file.fail()) throw runtime_error("Unable to open the file \"" + name + "\"");
    return Solution::read(file);
  }
}

void Solution::writeFile(const string &name) const {
  if (isGzipFilename(name)) {
    boost::iostreams::gzip_params params;
    params.level = 9;
    ofstream file(name, ios_base::out | ios_base::binary | ios_base::trunc);
    boost::iostreams::filtering_streambuf<boost::iostreams::output> out;
    out.push(boost::iostreams::gzip_compressor(params));
    out.push(file);
    std::ostream outf(&out);
    write(outf);
  }
  else {
    ofstream f(name);
    write(f);
  }
}

Hypergraph Hypergraph::readFile(const string &name) {
  if (isGzipFilename(name)) {
    ifstream file(name, ios_base::in | ios_base::binary);
    if (file.fail()) throw runtime_error("Unable to open the file \"" + name + "\"");
    boost::iostreams::filtering_streambuf<boost::iostreams::input> in;
    in.push(boost::iostreams::gzip_decompressor());
    in.push(file);
    std::istream inf(&in);
    return Hypergraph::readHgr(inf);
  }
  else {
    ifstream file(name);
    if (file.fail()) throw runtime_error("Unable to open the file \"" + name + "\"");
    return Hypergraph::readHgr(file);
  }
}

void Hypergraph::writeFile(const string &name) const {
  if (isGzipFilename(name)) {
    boost::iostreams::gzip_params params;
    params.level = 9;
    ofstream file(name, ios_base::out | ios_base::binary | ios_base::trunc);
    boost::iostreams::filtering_streambuf<boost::iostreams::output> out;
    out.push(boost::iostreams::gzip_compressor(params));
    out.push(file);
    std::ostream outf(&out);
    writeHgr(outf);
  }
  else {
    ofstream f(name);
    writeHgr(f);
  }
}

} // End namespace minipart

